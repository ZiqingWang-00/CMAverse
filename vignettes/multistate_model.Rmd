---
title: "Multistate modeling with a time-to-event mediator and a time-to-event outcome"
output: rmarkdown::html_vignette
date: "`r Sys.Date()`"
vignette: >
  %\VignetteIndexEntry{Multistate modeling with a time-to-event mediator and a time-to-event outcome}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache=TRUE)
knitr::opts_chunk$set(fig.width=6, fig.height=4)
library(tidyverse)
library(survminer)
library(mstate)
library(CMAverse)
```

## Introduction

This example demonstrates how to use `cmest` when there is a
time-to-event mediator and a time-to-event outcome. For this purpose, we
simulate a dataset with a binary exposure $A$, a time-to-event mediator
$M$, a time-to-event outcome $S$, and two baseline covariates: one
continuous ($C1$), and one binary ($C2$).

The Residual Disparity (RD) is defined as the difference in the
probability of surviving beyond time point s between the exposed group
(A=1) and the unexposed group (A=0), had the mediator distribution g
been the fixed to that of the unexposed group:
$$RD=P(S_{g_0}>s|A=1,C1,C2) - P(S_{g_0}>s|A=0,C1,C2)$$

The Shifting Distribution Effect (SD) is defined as the difference in
the probability of surviving beyond time s for the exposed group, had
its time to mediator distribution been changed to that of the unexposed
group:

$$SD=P(S_{g_1}>s|A=1,C1,C2) - P(S_{g_0}>s|A=1,C1,C2)$$

Consequently, we define the Total Effect (TE) as the difference in the
probability of surviving beyond time s between the exposed and the
unexposed group, without intervening on the time-to-mediator
distribution. As a result, TE is equal to the sum of RD and SD:
$$TE = RD+SDE = P(S>s|A=1,C1, C2) - P(S>s|A=0,C1, C2)$$

The DAG for this scientific setting is as follows:

```{r DAG of interest}
cmdag(outcome = "S", exposure = "A", mediator = "M",
      basec = c("C1", "C2"), postc = NULL, node = TRUE, text_col = "white")
```

## Data simulation

In this setting, we can use a multistate modeling approach to compute
the causal estimands of interest (RD, SD, and TE) in the presence of
semi-competing risks. We demonstrate how to achieve this using `cmest`.
First, we simulate data following the structure shown in the above DAG.
Specifically, we separately generate the following transitions under a
Cox proportional hazards model with the constant baseline hazard, i.e.,
assuming exponential time to event:

-   Transition 1 ($A \rightarrow M$):
    $\lambda_{01}(t|A,C1,C2) = \lambda_{01}^0(t)e^{a_1A+a_2C1+a_3C2} = 1.5 \cdot e^{=1.9A+0.2C1+0.5C2}$
-   Transition 2 ($A \rightarrow S$):
    $\lambda_{02}(t|A,C1,C2) = \lambda_{02}^0(t)e^{b_1A+b_3C1+b_4C2} = 1 \cdot e^{A-0.5C1-0.3C2}$
-   Transition 3 ($M \rightarrow S$):
    $\lambda_{12}(t|A,C1,C2) = \lambda_{12}^0(t)e^{c_1A+c_2M+c_3C1+c_4C2} = 0.8 \cdot e^{0.55A-0.15M -0.1C1-0.2C2}$

The code for generating the aforementioned data is as follows:

```{r data generation}
# set up coefficients 
# M (trans 1)
a1 = -1.9 
a2 = 0.2 
a3 = 0.5 

# S (trans 2)
b1 = 1 
b3 = -0.5
b4 = 0.3

# M when generating the semi-competing observations in resample() (trans 3)
# S (resample) (trans 3)
c1 = 0.55
c2 = -0.15 
c3 = -0.1 
c4 = -0.2 

#generate dataset
set.seed(8) # 1, 8
#build a function to generate time-to-event data
gen_srv <- function(n, lambda, beta, X){
  X = as.matrix(X)
  beta = as.matrix(beta, ncol=1)
  time = -log(runif(n)) / (lambda * exp(X %*% beta)) # exponential distribution
  return(time)
}

n <- 2000 #1000
A = sample(c(0,1),replace=TRUE, size=n, c(0.5,0.5)) #binary exposure
C1 = sample(c(0,1),replace=TRUE, size=n,c(0.6, 0.4)) #binary confounder
C2 = rnorm(n, mean = 1, sd = 1) #continuous confounder
id=c(1:n)
full = data.frame(id,A,C1,C2)
M = gen_srv(n=n, lambda = 1.5, beta = c(a1,a2,a3), X=data.frame(A,C1,C2)) #time to event mediator
S = gen_srv(n=n, lambda = 1, beta = c(b1,b3,b4), X=data.frame(A,C1,C2)) #time to event outcome
data = data.frame(id = c(1:n), M = M, S = S)
# indicator for event
data$ind_M = ifelse(data$M <= data$S, 1, 0)
data$ind_S = 1
data <- merge(data,full , by = "id")
#modify Y distribution
trans_matrix = transMat(x = list(c(2, 3), c(3), c()), names = c("A", "M", "S"))
covs = c("A","M", "C1","C2")
pre_data = msprep(time = c(NA, "M", "S"), status = c(NA, "ind_M", "ind_S"),
                         data = data, trans = trans_matrix, keep = covs)
pre_data = expand.covs(pre_data, covs, append = TRUE, longnames = FALSE)
#pre_data$A_M.3 = pre_data$A.3*pre_data$M.3
# resample for T < S
data_23 = pre_data[which(pre_data$trans == 3),]
data_23_tem = data.frame(id = rep(NA,dim(data_23)[1]),
                         new_y = rep(NA,dim(data_23)[1]))
paste("# to resample is ", nrow(data_23))

for(i in 1:dim(data_23)[1]){
  data_23_tem$id[i] = data_23$id[i]
  repeat {
    time_test = gen_srv(n = 1, 
                        lambda = 0.8,
                        beta = c(as.numeric(c1),
                                 c2,
                                 as.numeric(c3),
                                 as.numeric(c4)), 
                        X = data_23[i, c("A.3", "M.3", "C1.3","C2.3")])
    # exit if the condition is met
    if (time_test > data_23[i,"M.3"]) break
  }
  data_23_tem$new_y[i] = time_test
}
data_temp = merge(data, data_23_tem, by = "id", all = T)
# modify Y and M
data_temp$S[which(data_temp$ind_M == 1)] = data_temp$new_y[which(data_temp$ind_M == 1)]
data_temp$M[which(data_temp$ind_M == 0)] = data_temp$S[which(data_temp$ind_M == 0)]
data_final = data_temp
data_final$A = as.factor(data_final$A) #generate a factor exposure

sc_data = data_final %>% dplyr::select(id,A,M,S,ind_M,ind_S,C1,C2)

# generate time to censoring C; compare C to S; update event indicator
time_to_censor = runif(n, 0, 2*max(sc_data$S))
sc_data$ind_S = ifelse(sc_data$S > time_to_censor, 0, 1)
sc_data$A = factor(sc_data$A)
sc_data$C1 = factor(sc_data$C1)

```

We fit the multistate Cox proportional hazards model to the simulated
data. We can see that the regression coefficient estimates are close to
the set-up values, which is expected:

```{r check coefficient values}
# fit mstate model on sc_data
## prepare sc_data into mstate
mstate_sc_data = msprep(time = c(NA, "M", "S"), status = c(NA, "ind_M", "ind_S"),
                         data = sc_data, trans = trans_matrix, keep = covs)
mstate_sc_data = expand.covs(mstate_sc_data, covs, append = TRUE, longnames = FALSE)

## fit mstate model
sc_joint_mod = coxph(Surv(Tstart, Tstop, status) ~ A.1 + A.2 + A.3 +
                         M.3 + C1.1 + C1.2 + C1.3 + C2.1 + C2.2 + C2.3 + strata(trans),
                      data = mstate_sc_data)
summary(sc_joint_mod)
```

Below, we visualize the time-to-mediator and the time-to-event
distributions by exposure group for all subjects with $C1=1$:

```{r Take a look at the simulated data}
# overlayed histogram of mediator and outcome
hist_sc <- data.frame(value = c(sc_data$M, sc_data$S),
                 group = c(rep("M", length(sc_data$M)),
                           rep("S", length(sc_data$S))))
ggplot(hist_sc, aes(x = value, fill = group)) +
  geom_histogram(position = "identity", alpha = 0.5, bins = 50) +
  labs(title = "Overlayed Histogram of M and S",
       x = "Observed time",
       y = "Frequency") +
  scale_fill_manual(values = c("blue", "red"))

# survival curve by treatment group (A=1 vs. A=0) within strata C=1
survival_fit_sc <- survfit(Surv(S, ind_S) ~ A, data = sc_data %>% filter(C1==1))
ggsurvplot(survival_fit_sc, data = sc_data, pval = T)
ggsurvplot(survfit(Surv(M, ind_M) ~ A, data = sc_data %>% filter(C1==1)), data = sc_data, pval = T)
```

## Demonstration

Next, we show how to use the `cmest` function to calculate RD and SD for
time points 0.1, 0.5, 1, 2, 3, 4, 5, 6. For demonstration purposes, we
only run 2 bootstraps here. More number of bootstraps are required in
real-world settings (usually \>1000), resulting in long computation
time.

```{r run multistate method on sc_data, results='hide'}
# specificy time points (s)
time_to_predict_sc <- c(0.1, 0.5, 1, 2, 3, 4, 5, 6)
# run cmest()
sc_data_result = cmest(data = sc_data, 
                                  model = 'multistate', 
                                  s = time_to_predict_sc,
                                  multistate_seed = 123,
                                  exposure = 'A', mediator = 'M', outcome = 'S',
                                  event = "ind_S",mediator_event = "ind_M",
                                  basec = c("C1", "C2"),
                                  basecval = c("C1" = "1", "C2" = as.character(mean(sc_data$C2))),
                                  astar="0", a="1", 
                                  nboot=2, EMint=F, 
                                  bh_method = "breslow")   

```

The output is a list that consists of 4 elements: 1) The model summary
of the joint multistate Cox proportional hazards model fitted on the
original dataset, 2) the point estimates of RD and SD for each of the
user-specified time points of interest on the original dataset, 3) the
summary of the bootstrapped RD, SD, and TE estimates for each of the
user-specified time point of interest, including the 2.5%, 50%, and
97.5% percentiles, and 4) the estimated RD, SD, TD for each of the
user-specified time point of interest for each bootstrap dataset. These
4 elements of the example output are extracted in order below:

```{r display cmest outputs}
sc_data_result$model_summary
sc_data_result$pt_est
sc_data_result$bootstrap_summary
sc_data_result$raw_output
```

To verify the validity of the output, we can compute the
theoretical/true RD and SD for the simulated data based on Valeri et al.
(2023):

```{r function to compute theoretical RD and SD}
# theoretical RD and SD for binary exposure
get_theo_RD_SD = function(s=1, C1=1, C2=1,
                          a_vec=c(a1, a2, a3),
                          b_vec=c(b1, b3, b4),
                          c_vec=c(c1, c2, c3, c4),
                          lambda_vec=c(1.5,1,0.8)){
  a1 = a_vec[1]
  a2 = a_vec[2]
  a3 = a_vec[3]
  b1 = b_vec[1]
  b3 = b_vec[2]
  b4 = b_vec[3]
  c1 = c_vec[1]
  c2 = c_vec[2]
  c3 = c_vec[3]
  c4 = c_vec[4]
  d = C2
  lambda1 = lambda_vec[1]
  lambda2 = lambda_vec[2]
  lambda3 = lambda_vec[3]
  
  P_00 = exp(-lambda1*exp(a2*C1+a3*d)*s - lambda2*exp(b3*C1+b4*d)*s)
  P_g_00 = exp(-lambda1*exp(a2*C1+a3*d)*s - lambda2*exp(b1+b3*C1+b4*d)*s)
  P_g_01_func = function(t){
    exp(-lambda1*exp(a2*C1+a3*d)*t - lambda2*exp(b1+b3*C1+b4*d)*t) * lambda1*exp(a2*C1+a3*d) * exp(lambda3*exp(c1+c2*t+c3*C1+c4*d) * (t-s)) 
  }
  P_01_func = function(t){
    exp(-lambda1*exp(a2*C1+a3*d)*t - lambda2*exp(b3*C1+b4*d)*t) * lambda1*exp(a2*C1+a3*d) * exp(lambda3*exp(c2*t+c3*C1+c4*d) * (t-s)) 
  }

  P_g_01 = integrate(P_g_01_func, lower = 0, upper = s)
  P_01 = integrate(P_01_func, lower=0, upper = s)

  # theoretical RD
  theoretical_RD = (P_g_00 + P_g_01$value) - (P_00 + P_01$value)

  SD_1 = exp(-lambda1*exp(a1+a2*C1+a3*d)*s - lambda2*exp(b1+b3*C1+b4*d)*s)
  SD_2_func = function(t){
    exp(-lambda1*exp(a1+a2*C1+a3*d)*t - lambda2*exp(b1+b3*C1+b4*d)*t) * lambda1*exp(a1+a2*C1+a3*d) * exp(lambda3*exp(c1+c2*t+c3*C1+c4*d) * (t-s)) 
  }
  SD_2 = integrate(SD_2_func, lower = 0, upper = s)
  # theoretical SD
  theoretical_SD = (SD_1 + SD_2$value) - (P_g_00 + P_g_01$value)

  return(c(RD = theoretical_RD, SD = theoretical_SD))
  #return(c(RD = theoretical_RD, SD = theoretical_SD,
  #         P_00 = P_00, P_01 = P_01$value, P_g_00 = P_g_00, P_g_01 = P_g_01$value, 
  #         SD_1 = SD_1, SD_2 = SD_2$value))
}

theo_list = list()
for (i in 1:length(time_to_predict_sc)){
  theo_list[[i]] = get_theo_RD_SD(s=time_to_predict_sc[i], C1=1, C2=1,
               a_vec=c(a1, a2, a3),
               b_vec=c(b1, b3, b4),
               c_vec=c(c1, c2, c3, c4),
               lambda_vec=c(1.5,1.0,0.8))
  }

theo_mat = round(do.call(rbind, theo_list), 5)
rownames(theo_mat) = time_to_predict_sc
theo_mat
```

Below is a plot that overlays the theoretical values of RD and SD
(denoted as RD_true and SD_true, respectively) with the RD and SD
estimated using the original simulated dataset (denoted as RD_pt_est and
SD_pt_est, respectively) for each user-specified time point of interest.

```{r visualize the theoretical and estimated RD and SD}
theo_vals = theo_mat[,c("RD", "SD")]
s_vec = as.numeric(rownames(theo_mat))
result_comp = data.frame(s = time_to_predict_sc,
                         RD_true = theo_mat[,"RD"],
                         SD_true = theo_mat[,"SD"],
                         RD_pt_est = sc_data_result$pt_est$RD,
                         SD_pt_est = sc_data_result$pt_est$SD) %>%
  pivot_longer(cols = -s, names_to = "metric", values_to = "value") %>%
  mutate(type = ifelse(grepl("RD", metric), "RD", "SD" ))

combined_comp_plot = ggplot(result_comp, aes(x = s, y = value, group=metric, color=type)) +
  geom_point() +
  geom_line(aes(linetype = metric)) +
  scale_color_manual(values = c("SD" = "blue", "RD" = "red")) +
  scale_linetype_manual(values = c("RD_true" = "solid", "RD_pt_est" = "dotdash", 
                                   "SD_true" = "solid", "SD_pt_est" = "dotdash")) +
  theme_minimal() +
  labs(title = "Overlayed theoretical and estimated values of RD and SD", x = "s", y = "value")

combined_comp_plot

```

## Reference

[1] Valeri, L., Proust-Lima, C., Fan, W., Chen, J. T., & Jacqmin-Gadda,
H. (2023). A multistate approach for the study of interventions on an
intermediate time-to-event in health disparities research. Statistical
Methods in Medical Research, 09622802231163331.
